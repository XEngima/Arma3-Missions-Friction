/*
 * Name:	Mission
 * Date:	2020-06-24
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Base class for all missions in the campaign.
 */

using Sqx.Services;
using Mission.Common;

namespace Mission.Server
{
	public class Mission : Service
	{
		private fields ["_mActingSide" as Side, "_mSpawnedVehicles" as Array /* of Object */];
		
		public constructor("_actingSide" as Side)
		{
			call _base.Constructor;
			
			_mActingSide = _actingSide;
			_mSpawnedVehicles = [];
			
			_self.StartTime = 12;
			_self.RemainingTime = 30;
			_self.ActingSideStartMarkers = [];
			_self.OpposingSideStartMarkers = [];
			_self.ActingSideMarkers = [];
			_self.OpposingSideMarkers = [];
			_self.ActingPlayers = [];
			_self.OpposingPlayers = [];
		};
		
		protected method Side GetActualSide("_side" as MissionSide)
		{
			if (_mActingSide == west) then {
				if (_side == MissionSide.Acting) then {
					return west;
				}
				else {
					return east;
				};
			}
			else // If acting side is east
			{
				if (_side == MissionSide.Acting) then {
					return east;
				}
				else {
					return west;
				};
			};
		};
		
		protected method MissionSide GetMissionSide("_side" as Side)
		{
			if (_side == _mActingSide) then {
				return MissionSide.Acting;
			};
			
			return MissionSide.Opposing;
		};
		
		protected static method Boolean IsAlive("_player" as Object)
		{
			return _player != objNull && { alive _player && _player getVariable ["IsAlive", false] };
		};
		
		// Spawns a vehicle on a marker.
		// _vehicleType (String): The vehicle type to spawn.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		private method Object SpawnVehicle("_vehicleType" as String, "_spawnMarker" as String)
		{
			private _position = getMarkerPos _spawnMarker;
			private _direction = markerDir _spawnMarker;
			
			private _vehicle = _vehicleType createVehicle [_position select 0, _position select 1, (_position select 2) - 100];
			_vehicle setDir _direction;
			_vehicle setPos _position;
			
			_mSpawnedVehicles pushBack _vehicle;
			
			return _vehicle;
		};
		
		// Spawns a vehicle on a marker at the scene.
		// _vehicleTypeWest (String): The vehicle type spawned if side is west.
		// _vehicleTypeEast (String): The vehicle type spawned if side is east.
		// _missionSide (MissionSide): The side (acting or opposing) that owns the vehicle.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		protected method Object SpawnVehicleAtScene("_vehicleTypeWest" as String, "_vehicleTypeEast" as String, "_missionSide" as MissionSide, "_spawnMarker" as String)
		{
			private _side = [_missionSide] call _self.GetActualSide;
			private _vehicleType = if (_side == west) then { _vehicleTypeWest  } else { _vehicleTypeEast };
			
			return [_vehicleType, _spawnMarker] call _self.SpawnVehicle;
		};
		
		// Spawns a vehicle in the base.
		// _vehicleTypeWest (String): The vehicle type spawned for side west.
		// _vehicleTypeEast (String): The vehicle type spawned for side east.
		// _missionSide (MissionSide): The side (acting or opposing) that owns the vehicle.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		protected method Object SpawnVehicleAtBase("_vehicleTypeWest" as String, "_vehicleTypeEast" as String, "_missionSide" as MissionSide, "_baseMarker" as BaseMarker)
		{
			private _side = [_missionSide] call _self.GetActualSide;
			private _vehicleType = if (_side == west) then { _vehicleTypeWest  } else { _vehicleTypeEast };
			
			private _spawnMarker = "";
			
			switch (_baseMarker) do
			{
				case BaseMarker.AmmoCrate: {
					if (_side == west) then {
						_spawnMarker = "base_west_AmmoCrateMarker";
					}
					else {
						_spawnMarker = "base_east_AmmoCrateMarker";
					};
				};
			};
			
			return [_vehicleType, _spawnMarker] call _self.SpawnVehicle;
		};
		
		public property Scalar RemainingTime { get; set; };
		
		protected property Scalar StartTime { get; protected set; };
		
		protected property Array ActingPlayers { get; protected set; };
		
		protected property Array OpposingPlayers { get; protected set; };
		
		protected property Array ActingSideStartMarkers { get; protected set; };
		
		protected property Array OpposingSideStartMarkers { get; protected set; };
		
		protected property Array ActingSideMarkers { get; protected set; };
		
		protected property Array OpposingSideMarkers { get; protected set; };
		
		public method Array GetStartMarkers("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return _self.ActingSideStartMarkers;
			};
			
			return _self.OpposingSideStartMarkers;
		};
	
		public method Array GetMarkers("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return _self.ActingSideMarkers;
			};
			
			return _self.OpposingSideMarkers;
		};
		
		public method MissionResultInfo GetMissionResult("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return [call _self.PrimaryTargetFulfilledForActing, call _self.SecondaryTargetFulfilledForActing, count _self.ActingPlayers, { [_x] call Mission.IsAlive } count _self.ActingPlayers] new MissionResultInfo;
			}
			else {
				return [call _self.PrimaryTargetFulfilledForOpposing, call _self.SecondaryTargetFulfilledForOpposing, count _self.OpposingPlayers, { [_x] call Mission.IsAlive } count _self.OpposingPlayers] new MissionResultInfo;
			};
		};
	
		// Initializes the mission, i.e. creating and placing vehicles and such.
		public virtual method Setup()
		{
			private _timeToSkip = 24 - daytime + _self.StartTime;
		
			skipTime _timeToSkip;
			
			call _self.CreateTargets;
		};

		protected property MissionTask PrimaryTargetForActing { get; private set; };
		
		protected property MissionTask SecondaryTargetForActing { get; private set; };
		
		protected property MissionTask PrimaryTargetForOpposing { get; private set; };
		
		protected property MissionTask SecondaryTargetForOpposing { get; private set; };

		private method CreateTargets()
		{
			_self.PrimaryTargetForActing = call _self.CreatePrimaryTargetForActing;
			_self.SecondaryTargetForActing = call _self.CreateSecondaryTargetForActing;
			_self.PrimaryTargetForOpposing = call _self.CreatePrimaryTargetForOpposing;
			_self.SecondaryTargetForOpposing = call _self.CreateSecondaryTargetForOpposing;
		};

		protected virtual method MissionTask CreatePrimaryTargetForActing()
		{
			return ["Do whatever you want."] new MissionTask;
		};
		
		protected virtual method MissionTask CreateSecondaryTargetForActing()
		{
			return classNull;
		};
		
		protected virtual method MissionTask CreatePrimaryTargetForOpposing()
		{
			return ["Do whatever you want."] new MissionTask;
		};
		
		protected virtual method MissionTask CreateSecondaryTargetForOpposing()
		{
			return classNull;
		};
		
		protected virtual method Boolean PrimaryTargetFulfilledForActing()
		{
			return false;
		};
		
		protected virtual method Boolean SecondaryTargetFulfilledForActing()
		{
			return false;
		};
		
		protected virtual method Boolean PrimaryTargetFulfilledForOpposing()
		{
			return false;
		};
		
		protected virtual method Boolean SecondaryTargetFulfilledForOpposing()
		{
			return false;
		};
		
		// Checks if mission is completed for the acting side.
		// Remarks: Default behavior is to return true if both primary and secondary
		//          targets are complete. If primary target is null, then the mission
		//          is never complete. If secondary target is null, then the mission
		//          is considered complete when the primary target is complete.
		// Returns (Boolean): true if mission is completed, else false.
		protected virtual method Boolean IsMissionCompleteForActing()
		{
			private ["_primaryTarget" as MissionTask, "_secondaryTarget" as MissionTask];
			
			_primaryTarget = _self.PrimaryTargetForActing;
			_secondaryTarget = _self.SecondaryTargetForActing;
			
			if (isNull _primaryTarget) then {
				return false;
			};
			
			if (call _self.PrimaryTargetFulfilledForActing) then
			{
				if (isNull _secondaryTarget) then {
					return true;
				}
				else {
					return call _self.SecondaryTargetFulfilledForActing;
				};
			};
		};
		
		// Checks if mission is completed for the opposing side.
		// Remarks: Default behavior is to return true if both primary and secondary
		//          targets are complete. If primary target is null, then the mission
		//          is never complete. If secondary target is null, then the mission
		//          is considered complete when the primary target is complete.
		// Returns (Boolean): true if mission is completed, else false.
		protected virtual method Boolean IsMissionCompleteForOpposing()
		{
			private ["_primaryTarget" as MissionTask, "_secondaryTarget" as MissionTask];
			
			_primaryTarget = _self.PrimaryTargetForOpposing;
			_secondaryTarget = _self.SecondaryTargetForOpposing;
			
			if (isNull _primaryTarget) then {
				return false;
			};
			
			if (call _self.PrimaryTargetFulfilledForOpposing) then
			{
				if (isNull _secondaryTarget) then {
					return true;
				}
				else {
					return call _self.SecondaryTargetFulfilledForOpposing;
				};
			};
		};
		
		// Called one time for each side that performs an insertion to begin carrying out the mission.
		// _side (Side): The side of the group that is being inserted.
		// _position (Array): The position where the group is inserted.
		public method InsertGroup("_group" as Group, "_position" as Array)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [side _group] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				_self.ActingPlayers = units _group;
				[side _group, _position] call _self.OnActingGroupInserted;
			}
			else {
				_self.OpposingPlayers = units _group;
				[side _group, _position] call _self.OnOpposingGroupInserted;
			};
		};
		
		protected virtual method OnActingGroupInserted("_side" as Side, "_position" as Array)
		{
		};
		
		protected virtual method OnOpposingGroupInserted("_side" as Side, "_position" as Array)
		{
		};
		
		// Cleans up everything that was created in the Setup method.
		public virtual method Cleanup()
		{
			{
				deleteVehicle _x;
			} foreach _mSpawnedVehicles as Object;
		};
		
		protected override method Run()
		{
			while { !_self.IsCancelling } do
			{
				if (call _self.IsMissionCompleteForActing && call _self.IsMissionCompleteForOpposing) then {
					call _self.Cancel;
				};
				
				sleep 1;
			};
			
			player sideChat "turning off mission.";
			call _base.Run;
		};
	};
};
