/*
 * Name:	Campaign
 * Date:	2020-06-24
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * A Friction Campaign.
 */

using Sqx.Services;
using Mission.Communication;
using Mission.Common;

namespace Mission.Server
{
	public class Campaign : Service
	{
		private fields ["_mBaseMarkersConfig" as IBaseMarkersConfig, "_mMissions" as Array /* of Mission */, "_mWestlyUnits" as Array, "_mEastlyUnits" as Array];
		private fields ["_mCurrentMission" as Mission, "_mEastHasInserted" as Boolean, "_mWestHasInserted" as Boolean];
		private fields ["_mWestPrimaryObjectiveCompleted" as Boolean, "_mWestSecondaryObjectiveCompleted" as Boolean, "_mEastPrimaryObjectiveCompleted" as Boolean, "_mEastSecondaryObjectiveCompleted" as Boolean];
		private fields ["_mGainedTokensActing" as Array /* of HistoryToken */, "_mLostTokensActing" as Array, "_mGainedTokensOpposing" as Array, "_mLostTokensOpposing" as Array];
	
		// Creates a Campaign object.
		public constructor("_baseMarkersConfig" as IBaseMarkersConfig)
		{
			call _base.Constructor;
			_mBaseMarkersConfig = _baseMarkersConfig;
			
			call _self.ClearAllMapMarkers;
			
			_mMissions = [
				[_mBaseMarkersConfig, west] new LostVehicles,
				[_mBaseMarkersConfig, west] new HawkDown,
				[_mBaseMarkersConfig, east] new AirStationAssault
//				[_mBaseMarkersConfig, west] new AirBaseMadness
			];
		};
		
		private method ClearAllMapMarkers()
		{
			{
				_x setMarkerAlpha 0;
			} foreach allMapMarkers as String;
		};
		
		protected static method Boolean IsAlive("_player" as Object)
		{
			return _player != objNull && { alive _player && _player getVariable ["IsAlive", false] };
		};
		
		private method NotifyAboutMissionStart("_mission" as Mission)
		{
			private ["_startMarkers" as Array /* of MarkerInfo */, "_markers" as Array /* of MarkerInfo */, "_missionMarkersInfo" as MissionMarkersInfo];
			
			_startMarkers = [];
			_markers = [];
			
			{
				_startMarkers pushBack [_x, west] new MarkerInfo;
			} foreach [west] call _mission.GetStartMarkers as String;
			
			{
				_startMarkers pushBack [_x, east] new MarkerInfo;
			} foreach [east] call _mission.GetStartMarkers as String;
			
			{
				_markers pushBack [_x, west] new MarkerInfo;
			} foreach [west] call _mission.GetMarkers as String;
			
			{
				_markers pushBack [_x, east] new MarkerInfo;
			} foreach [east] call _mission.GetMarkers as String;
			
			_missionMarkersInfo = [_startMarkers, _markers] new MissionMarkersInfo;
		
			[_missionMarkersInfo] call PublicVariableHandler.BroadcastMissionMarkersInfo;
			[CampaignPhase.MissionPlanning] call PublicVariableHandler.BroadcastCampaignPhase;
			["ClientEventReciever.OnMissionSetup", [_missionMarkersInfo]] call Remote.Invoke;
			
			// TODO: Perform insertion in base for groups that have no start markers
			/*
			private _westStartMarkers = [west] call _missionMarkersInfo.GetStartMarkersBySide;
			
			if (count _westStartMarkers == 0) then {
				[0, [west, BaseMarker.Respawn] call _mBaseMarkersConfig.GetMarkerName] call _self.InsertGroup;
			};
			*/
		};
		
		private method NotifyAboutMissionBriefing("_mission" as Mission)
		{
			private ["_missionBriefing" as MissionBriefing];
		
			private _westPrimaryObjective = [west, ObjectivePrio.Primary] call _mission.GetMissionObjective;
			private _westSecondaryObjective = [west, ObjectivePrio.Secondary] call _mission.GetMissionObjective;
			private _eastPrimaryObjective = [east, ObjectivePrio.Primary] call _mission.GetMissionObjective;
			private _eastSecondaryObjective = [east, ObjectivePrio.Secondary] call _mission.GetMissionObjective;
			
			_missionBriefing = [_westPrimaryObjective, _westSecondaryObjective, _eastPrimaryObjective, _eastSecondaryObjective] new MissionBriefing;
			
			[_missionBriefing] call PublicVariableHandler.BroadcastMissionBriefing;
			["ClientEventReciever.OnMissionBriefing", [_missionBriefing]] call Remote.Invoke;
		};

		public method InsertGroup("_group" as Group, "_position" as Array)
		{
			if (side _group == west) then
			{
				if (!_mWestHasInserted) then
				{
					[_group, _position] call _mCurrentMission.InsertGroup;
					_mWestlyUnits = units _group;
					
					{
						_x setVariable ["IsAlive", true, true];
					} foreach units _group as Object;
					
					_mWestHasInserted = true;
					[true] call PublicVariableHandler.BroadcastWestHasInserted;
				};
			}
			else // East
			{
				if (!_mEastHasInserted) then
				{
					[_group, _position] call _mCurrentMission.InsertGroup;
					_mEastlyUnits = units _group;
					
					{
						_x setVariable ["IsAlive", true, true];
					} foreach units _group as Object;
					
					_mEastHasInserted = true;
					[true] call PublicVariableHandler.BroadcastEastHasInserted;
				};
			};
		};
		
		private method Boolean AllUnitsAreDead()
		{
			if ((count _mEastlyUnits) + (count _mWestlyUnits) == 0) then {
				return false;
			};
		
			{
				if ([_x] call _self.IsAlive) then {
					return false;
				};
			} foreach _mWestlyUnits as Object;
			
			{
				if ([_x] call _self.IsAlive) then {
					return false;
				};
			} foreach _mEastlyUnits as Object;
			
			return true;
		};
		
		private method CheckAndNotifyObjectives("_mission" as Mission)
		{
			if (_mWestHasInserted) then
			{
				if (!_mWestPrimaryObjectiveCompleted && { [west, ObjectivePrio.Primary] call _mission.CheckObjectiveCompleted }) then
				{
					["ClientEventReciever.OnTaskStateChanged", [west, ObjectivePrio.Primary, TaskState.Succeeded]] call Remote.Invoke;
					_mWestPrimaryObjectiveCompleted = true;
				};
				
				if (!_mWestSecondaryObjectiveCompleted && { [west, ObjectivePrio.Secondary] call _mission.CheckObjectiveCompleted }) then
				{
					["ClientEventReciever.OnTaskStateChanged", [west, ObjectivePrio.Secondary, TaskState.Succeeded]] call Remote.Invoke;
					_mWestSecondaryObjectiveCompleted = true;
				};
			};
			
			if (_mEastHasInserted) then
			{
				if (!_mEastPrimaryObjectiveCompleted && { [east, ObjectivePrio.Primary] call _mission.CheckObjectiveCompleted }) then
				{
					["ClientEventReciever.OnTaskStateChanged", [east, ObjectivePrio.Primary, TaskState.Succeeded]] call Remote.Invoke;
					_mEastPrimaryObjectiveCompleted = true;
				};
				
				if (!_mEastSecondaryObjectiveCompleted && { [east, ObjectivePrio.Secondary] call _mission.CheckObjectiveCompleted }) then
				{
					["ClientEventReciever.OnTaskStateChanged", [east, ObjectivePrio.Secondary, TaskState.Succeeded]] call Remote.Invoke;
					_mEastSecondaryObjectiveCompleted = true;
				};
			};
		};
		
		private method Boolean EndDueToCompletedObjectivesAndHumanPlayers()
		{
			if (_mWestPrimaryObjectiveCompleted && _mWestSecondaryObjectiveCompleted) then {
				{
					if ([_x] call _self.IsAlive && _x getVariable ["IsPlayer", false]) then {
						return false;
					};
				} foreach _mEastlyUnits as Object;
			};
			
			if (_mEastPrimaryObjectiveCompleted && _mEastSecondaryObjectiveCompleted) then {
				{
					if ([_x] call _self.IsAlive && _x getVariable ["IsPlayer", false]) then {
						return false;
					};
				} foreach _mWestlyUnits as Object;
			};
			
			return true;
		};
		
		private method SaveHistoryTokens("_mission" as Mission)
		{
			if (!isNull _mission.GainedTokenActing) then {
				_mGainedTokensActing pushBack _mission.GainedTokenActing;
			};
			if (!isNull _mission.LostTokenActing) then {
				_mLostTokensActing pushBack _mission.LostTokenActing;
			};
			if (!isNull _mission.GainedTokenOpposing) then {
				_mGainedTokensOpposing pushBack _mission.GainedTokenOpposing;
			};
			if (!isNull _mission.LostTokenOpposing) then {
				_mLostTokensOpposing pushBack _mission.LostTokenOpposing;
			};
		};
		
		protected override method Run()
		{
			private ["_missionResultWest" as MissionResultInfo, "_missionResultEast" as MissionResultInfo];
			
			_mGainedTokensActing = [];
			_mLostTokensActing = [];
			_mGainedTokensOpposing = [];
			_mLostTokensOpposing = [];
			private _accumulatedScoreWest = 0;
			private _accumulatedScoreEast = 0;
			
			// Run each mission
			
			{
				_mCurrentMission = _x;
				_mEastHasInserted = false;
				_mWestHasInserted = false;
				_mEastlyUnits = [];
				_mWestlyUnits = [];
				_mWestPrimaryObjectiveCompleted = false;
				_mWestSecondaryObjectiveCompleted = false;
				_mEastPrimaryObjectiveCompleted = false;
				_mEastSecondaryObjectiveCompleted = false;
				
				private _remainingTime = _mCurrentMission.RemainingTime;
				
				// Override the mission's own remaining time with 30 minutes if it is too long
				if (_remainingTime > 30) then {
					_mCurrentMission.RemainingTime = 30;
					_remainingTime = 30;
				};
				
				[_mCurrentMission] call _self.NotifyAboutMissionStart;
				
				[_mGainedTokensActing, _mLostTokensActing, _mGainedTokensOpposing, _mLostTokensOpposing] call _mCurrentMission.SetHistoryTokens;
				call _mCurrentMission.Setup;
				
				[_mCurrentMission] call _self.NotifyAboutMissionBriefing;
				
				private _startTime = time;
				private _endTime = time + _remainingTime * 60;
				
				call _mCurrentMission.RunAsync;
				
				while { _mCurrentMission.IsRunning } do
				{
					// Calculate remaining time
					_remainingTime = floor (1 + (_endTime - time) / 60);
					
					if (_remainingTime != _mCurrentMission.RemainingTime) then
					{
						_mCurrentMission.RemainingTime = _remainingTime;
						["ClientEventReciever.OnMissionTimeTick", [_remainingTime]] call Remote.Invoke;
					};
					
					// If time is up, cancel the mission.
					
					if (time > _endTime) then {
						_mCurrentMission.RemainingTime = 0;
						call _mCurrentMission.Cancel;
					};
					
					// If all players are dead, cancel the mission.
					
					if (call _self.AllUnitsAreDead) then
					{
						call _mCurrentMission.Cancel;
					};
					
					[_mCurrentMission] call _self.CheckAndNotifyObjectives;
					
					// End mission if one side has completed objectives and there are no humans on the other side
					// Doesn't work...
					
//					if (call _self.EndDueToCompletedObjectivesAndHumanPlayers) then {
//						call _mCurrentMission.Cancel;
//					};
					
					sleep 1;
				};
				
				// Take care of eventual gained and lost tokens
				[_mCurrentMission] call _self.SaveHistoryTokens;
				
				// Tell players that mission has ended and beam them back to base.
				_missionResultWest = [west] call _mCurrentMission.GetMissionResult;
				_missionResultEast = [east] call _mCurrentMission.GetMissionResult;
				
				[false] call PublicVariableHandler.BroadcastWestHasInserted;
				[false] call PublicVariableHandler.BroadcastEastHasInserted;
				
				sleep 1;
				
				_accumulatedScoreWest = _accumulatedScoreWest + _missionResultWest.Score;
				_accumulatedScoreEast = _accumulatedScoreEast + _missionResultEast.Score;
				
				["ClientEventReciever.OnMissionEnded", [[_mCurrentMission.Name, _missionResultWest, _missionResultEast] new MissionResult, _accumulatedScoreWest, _accumulatedScoreEast]] call Remote.Invoke;
				
				sleep 4;
				
				call _mCurrentMission.Cleanup;
			} foreach _mMissions as Mission;

			["ClientEventReciever.OnCampaignEnded", [_accumulatedScoreWest, _accumulatedScoreEast]] call Remote.Invoke;
			
			call _base.Run;
		};
	};
};
