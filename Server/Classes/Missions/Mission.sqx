/*
 * Name:	Mission
 * Date:	2020-06-24
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Base class for all missions in the campaign.
 * A new mission is easily created by creating a class and inheriting this Mission base class.
 */

using Sqx.Services;
using Mission.Common;
using Mission.Communication;

namespace Mission.Server
{
	public class Mission : Service
	{
		private fields ["_mBaseMarkersConfig" as IBaseMarkersConfig, "_mActingSide" as Side, "_mSpawnedVehicles" as Array /* of Object */];
		private fields ["_mSpawnedSoldiers" as Array];
		
		// Creates a mission and sets primitive properties like start time of day and start markers.
		// _actingSide (Side): The side (east or west) that will act like the "acting" side in the mission.
		public constructor("_baseMarkersConfig" as IBaseMarkersConfig, "_actingSide" as Side)
		{
			call _base.Constructor;
			
			_self.VehicleTypeDictionary = new VehicleTypeDictionary;
			_self.SoldierTypeDictionary = new SoldierTypeDictionary;
			_mBaseMarkersConfig = _baseMarkersConfig;
			_mActingSide = _actingSide;
			_mSpawnedVehicles = [];
			_mSpawnedSoldiers = [];
			_self.ActingPlayers = [];
			_self.OpposingPlayers = [];
			_self.PrimaryObjectiveCompletedForActing = false;
			_self.SecondaryObjectiveCompletedForActing = false;
			_self.PrimaryObjectiveCompletedForOpposing = false;
			_self.SecondaryObjectiveCompletedForOpposing = false;
			
			_self.Name = "New Mission";
			_self.StartTimeOfDay = 12;
			_self.RemainingTime = 30;
			_self.StartMarkersActing = [];
			_self.StartMarkersOpposing = [];
			_self.SideMarkersActing = [];
			_self.SideMarkersOpposing = [];
			
			call _self.Initialize;
		};
		
		#region Private Methods

		// Creates objectives for both sides and sets all primary- and secondary objective attributes for
		// the mission.
		private method CreateMissionObjectives()
		{
			_self.PrimaryObjectiveForActing = call _self.CreatePrimaryObjectiveForActing;
			_self.SecondaryObjectiveForActing = call _self.CreateSecondaryObjectiveForActing;
			_self.PrimaryObjectiveForOpposing = call _self.CreatePrimaryObjectiveForOpposing;
			_self.SecondaryObjectiveForOpposing = call _self.CreateSecondaryObjectiveForOpposing;
		};
		
		// Finds a free spawn position around a given position.
		// _markPos (Array): The position where to find a free spawn position.
		// _initialRadius (Scalar): Optional. The initial radius how far from the position that is ok. This
		// value will expand until a position is found.
		private static method FindSpawnPos("_markPos" as Array, ["_initialRadius" as Scalar, 0], ["_isHelicopter" as Boolean, false])
		{
			private ["_spawnpos", "_randir", "_extendedRadius", "_randis", "_houses", "_vehicles", "_isFlat", "_danger", "_foundIt", "_tries"];
			private ["_distanceToNearestVehicle" as Scalar, "_distanceFromBuilding" as Scalar, "_allowedSteepness" as Scalar];
			
			_distanceFromBuilding = 10;
			_allowedSteepness = 0.5;
			
			_distanceToNearestVehicle = 9;
			if (_isHelicopter) then {
				_distanceToNearestVehicle = 12;
				_allowedSteepness = 0.25;
			};
			
			_spawnpos = [];
			_foundIt = false;
			_tries = 0;
			_extendedRadius = 0;
			
			while { true } do {
				scopeName "SpawnPosGen";
				
				_randir = floor random 360;
				_randis = _initialRadius + floor random _extendedRadius;
				_spawnpos = [(_markpos select 0) + ((sin _randir) * _randis), (_markpos select 1) + ((cos _randir) * _randis), 0.1];
				_houses = nearestObjects [_spawnpos, ["house","wall"], 50];
				_vehicles = nearestObjects [_spawnpos, ["LandVehicle", "AirVehicle", "Man"], 25];
				_isFlat = _spawnpos isFlatEmpty [2, -1, _allowedSteepness, 10, 0, false, objNull ];
				_danger = false;
				{ if (floor(_spawnpos distance getPos _x) < _distanceFromBuilding) then { _danger=true; }; } forEach _houses;
				{ if (floor(_spawnpos distance getPos _x) < _distanceToNearestVehicle) then { _danger=true; }; } forEach _vehicles;
				if (surfaceIsWater _spawnpos) then { _danger=true; };
				if (count _isFlat < 1 ) then { _danger=true; };
				if (!_danger) then { 
					_foundIt = true;
					breakOut "SpawnPosGen"
				};
				_tries = _tries + 1;
				_extendedRadius = _extendedRadius + 0.5;
				sleep 0.01;
			};
			
			if (!_foundIt) then {
				_spawnPos = [];
			};
			
			return _spawnpos;
		};
		
		// Spawns a vehicle on a marker.
		// _vehicleType (String): The vehicle type to spawn.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		// Returns (Object): The vehicle spawned.
		protected method Object CreateVehicleOnMarker("_vehicleType" as String, "_markerName" as String, ["_avoidCollision" as Boolean, false], ["_withCrew" as Boolean, false])
		{
			private _position = getMarkerPos _markerName;
			
			if (_avoidCollision) then {
				_position = [_position] call _self.FindSpawnPos;
			};
			
			private _direction = markerDir _markerName;
			
			private _vehicle = _vehicleType createVehicle [_position select 0, _position select 1, (_position select 2) - 100];
			_vehicle setDir _direction;
			_vehicle setPos _position;
			
			_mSpawnedVehicles pushBack _vehicle;
			
			if (_withCrew) then {
				createVehicleCrew _vehicle;
			};
			
			return _vehicle;
		};
		
		// Spawns a vehicle on a marker.
		// _vehicleType (String): The vehicle type to spawn.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		// Returns (Object): The vehicle spawned.
		protected method Object CreateVehicleOnPosition("_vehicleType" as String, "_position" as Array, "_direction" as Scalar, ["_avoidCollision" as Boolean, false], ["_withCrew" as Boolean, false])
		{
			if (_avoidCollision) then {
				_position = [_position] call _self.FindSpawnPos;
			};
			
			private _vehicle = _vehicleType createVehicle [_position select 0, _position select 1, (_position select 2) - 100];
			_vehicle setDir _direction;
			_vehicle setPos _position;
			
			_mSpawnedVehicles pushBack _vehicle;
			
			if (_withCrew) then {
				createVehicleCrew _vehicle;
			};
			
			return _vehicle;
		};
		
		protected method Object CreateAiSoldier("_unitType" as String, "_position" as Array, "_group" as Group)
		{
			private _soldier = _group createUnit [_unitType, _position, [], 0, "NONE"];
			_mSpawnedSoldiers pushBack _soldier;
			
			return _soldier;
		};
		
		protected method Object CreateAiSoldierBySide("_unitTypeAlias" as String, "_missionSide" as MissionSide, "_position" as Array, ["_group" as Group, grpNull])
		{
			private _side = [_missionSide] call _self.GetActualSide;
			private _soldierType = [_unitTypeAlias, _side] call _self.SoldierTypeDictionary.GetSoldierType;
			
			if (isNull _group) then {
				_group = createGroup [_side, true];
			};
			
			return [_soldierType, _position, _group] call _self.CreateAiSoldier;
		};
		
		
		#endregion
		
		#region Settable Properties
		
		public property String Name { get; protected set; };
		
		// Gets or sets the insertion map markers for the acting side.
		// This property must be set in the initialization phase of the mission.
		// If this array is empty, then the group will be auto inserted in its base.
		protected property Array StartMarkersActing { get; protected set; };
		
		// Gets or sets the insertion map markers for the opposing side.
		// This property must be set in the initialization phase of the mission.
		// If this array is empty, then the group will be auto inserted in its base.
 		protected property Array StartMarkersOpposing { get; protected set; };
		
		// Gets or sets general markers that should be visible for the acting side.
		// This property must be set in the initialization phase of the mission.
		protected property Array SideMarkersActing { get; protected set; };
		
		// Gets or sets general markers that should be visible for the opposing side.
		// This property must be set in the initialization phase of the mission.
		protected property Array SideMarkersOpposing { get; protected set; };
		
		// Gets and sets the start time of day. E.g. 12 for in the middle of the day, or 0 for midnight.
		// This property may be set in the mission's construtor, and at mission startup, time is skipped ahead 
		// to this property value.
		protected property Scalar StartTimeOfDay { get; protected set; };
		
		// Gets and sets the remaining time of the mission in minutes. This property may be set in the mission's 
		// Initialize method, and after that it is updated by the campaign object. After Setup phase, this property
		// should only be read from.
		public property Scalar RemainingTime { get; set; };
		
		// Gets an array of history token keys gained in earlier missions for the acting side.
		protected property Array EarlierGainedTokensActing { get; private set; };
		
		// Gets an array of history token keys lost in earlier missions for the acting side.
		protected property Array EarlierLostTokensActing { get; private set; };
		
		// Gets an array of history token keys gained in earlier missions for the opposing side.
		protected property Array EarlierGainedTokensOpposing { get; private set; };
		
		// Gets an array of history token keys lost in earlier missions for the opposing side.
		protected property Array EarlierLostTokensOpposing { get; private set; };
		
		// Gets or sets something of free choice that may be of use in future missions for the acting side.
		public property HistoryToken GainedTokenActing { get; protected set; };
		
		// Gets or sets something of free choice that is considered lost and may affect future missions for the acting side.
		public property HistoryToken LostTokenActing { get; protected set; };
		
		// Gets or sets something of free choice that may be of use in future missions for the opposing side.
		public property HistoryToken GainedTokenOpposing { get; protected set; };
		
		// Gets or sets something of free choice that is considered lost and may affect future missions for the opposing side.
		public property HistoryToken LostTokenOpposing { get; protected set; };
		
		#endregion
		
		#region Protected Methods
		
		// Gets the actual side (east or west) out of a mission side (acting or opposing).
		// Avoid addressing the actual side in a mission. Instead use "mission side", i.e.
		// Acting and Opposing.
		// _side (MissionSide): The mission side to ask for (acting or opposing).
		// Returns (Side): The actual side that corresponds to the mission side.
		public method Side GetActualSide("_side" as MissionSide)
		{
			if (_mActingSide == west) then {
				if (_side == MissionSide.Acting) then {
					return west;
				}
				else {
					return east;
				};
			}
			else // If acting side is east
			{
				if (_side == MissionSide.Acting) then {
					return east;
				}
				else {
					return west;
				};
			};
		};
		
		// Gets the mission side (acting or opposing) out of an actual side (east or west).
		// _side (Side): The side to ask for (east or west).
		// Returns (MissionSide): The mission side that corresponds to the actual side.
		protected method MissionSide GetMissionSide("_side" as Side)
		{
			if (_side == _mActingSide) then {
				return MissionSide.Acting;
			};
			
			return MissionSide.Opposing;
		};
		
		// Shows a general notification - like a task completed message - to all players on one side.
		// _missionSide (MissionSide): The side to see the notification.
		// _text (String): The text to show.
		protected method ShowNotification("_missionSide" as MissionSide, "_text" as String)
		{
			private _side = [_missionSide] call _self.GetActualSide;
			
			["ClientEventReciever.OnMissionSetup", [_side, _text]] call Remote.Invoke;
		};
		
		// Checks whether a unit (player) is considered alive or not. Note that a player 
		// who has respawned may be alive and in the base, but should be considered dead
		// by the current mission, since it is no longer taking part.
		// _player (Object): The player unit to check.
		protected static method Boolean IsAlive("_player" as Object)
		{
			return _player != objNull && { alive _player && _player getVariable ["IsAlive", false] };
		};
		
		// Gets the number of players alive on the acting side.
		// Returns (Scalar): Number of alive players on the acting side.
		protected method Scalar CountActingPlayersAlive()
		{
			return { [_x] call Mission.IsAlive } count _self.ActingPlayers;
		};
		
		// Gets the number of players alive on the opposing side.
		// Returns (Scalar): Number of alive players on the opposing side.
		protected method Scalar CountOpposingPlayersAlive()
		{
			return { [_x] call Mission.IsAlive } count _self.OpposingPlayers;
		};
		
		// Spawns a vehicle on a marker at the scene of the mission.
		// _vehicleTypeWest (String): The vehicle type spawned if side is west.
		// _vehicleTypeEast (String): The vehicle type spawned if side is east.
		// _missionSide (MissionSide): The side (acting or opposing) that owns the vehicle.
		// _spawnMarker (String): The name of the marker specifying the vehicle's position and direction.
		// Returns (Object): The vehicle spawned.
		protected method Object CreateSideVehicleOnMarker("_vehicleTypeAlias" as String, "_missionSide" as MissionSide, "_markerName" as String, ["_avoidCollision" as Boolean, false], ["_withCrew" as Boolean, false])
		{
			private _side = [_missionSide] call _self.GetActualSide;
			private _vehicleType = [_vehicleTypeAlias, _side] call _self.VehicleTypeDictionary.GetVehicleType;
			
			return [_vehicleType, _markerName, _avoidCollision, _withCrew] call _self.CreateVehicleOnMarker;
		};
		
		// Spawns a vehicle in the base.
		// _vehicleTypeWest (String): The vehicle type spawned for side west.
		// _vehicleTypeEast (String): The vehicle type spawned for side east.
		// _missionSide (MissionSide): The side (acting or opposing) that owns the vehicle.
		// _baseMarker (BaseMarker): The marker type that will translate to a marker in the base.
		// Returns (Object): The vehicle spawned.
		protected method Object CreateSideVehicleOnBaseMarker("_vehicleTypeAlias" as String, "_missionSide" as MissionSide, "_baseMarker" as BaseMarker, ["_avoidCollision" as Boolean, false], ["_withCrew" as Boolean, false])
		{
			private _side = [_missionSide] call _self.GetActualSide;
			private _vehicleType = [_vehicleTypeAlias, _side] call _self.VehicleTypeDictionary.GetVehicleType;
			private _spawnMarker = [_side, _baseMarker] call _mBaseMarkersConfig.GetMarkerName;
			
			return [_vehicleType, _spawnMarker, _avoidCollision, _withCrew] call _self.CreateVehicleOnMarker;
		};
		
		#endregion
		
		#region Protected Properties
		
		protected property VehicleTypeDictionary VehicleTypeDictionary { get; private set; };
		
		protected property SoldierTypeDictionary SoldierTypeDictionary { get; private set; };
		
		// Gets the players on the acting side that was inserted to execute the mission.
		// Use the IsAlive method to check if a player in this array is to be considered alive or dead.
		protected property Array ActingPlayers { get; private set; };
		
		// Gets the players on the opposing side that was inserted to execute the mission.
		// Use the IsAlive method to check if a player in this array is to be considered alive or dead.
		protected property Array OpposingPlayers { get; private set; };

		// Gets the primary objective briefing information for the acting side.
		protected property MissionObjective PrimaryObjectiveForActing { get; private set; };
		
		// Gets the secondary objective briefing information for the acting side. classNull if there is no secondary objective.
		protected property MissionObjective SecondaryObjectiveForActing { get; private set; };
		
		// Gets the primary objective briefing information for the opposing side.
		protected property MissionObjective PrimaryObjectiveForOpposing { get; private set; };
		
		// Gets the secondary objective briefing information for the opposing side. classNull if there is no secondary objective.
		protected property MissionObjective SecondaryObjectiveForOpposing { get; private set; };
		
		// Gets wheter the primary objective for the acting side has been completed.
		protected property Boolean PrimaryObjectiveCompletedForActing { get; private set; };

		// Gets wheter the secondary objective for the acting side has been completed.
		protected property Boolean SecondaryObjectiveCompletedForActing { get; private set; };
		
		// Gets wheter the primary objective for the opposing side has been completed.
		protected property Boolean PrimaryObjectiveCompletedForOpposing { get; private set; };
		
		// Gets wheter the secondary objective for the opposing side has been completed.
		protected property Boolean SecondaryObjectiveCompletedForOpposing { get; private set; };
		
		#endregion
		
		#region Public Methods
		
		// Gets the start markers for a side.
		// This method is used by the framework to enable mission insertion.
		// _side (Side): The side to get start markers for (east or west).
		// Returns (Array of String): Start marker names in an array.
		public method Array GetStartMarkers("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return _self.StartMarkersActing;
			};
			
			return _self.StartMarkersOpposing;
		};
	
		// Gets general map markers that should be visible for a side.
		// This method is used by the framework to know which markers to show for each side.
		// _side (Side): The side to get markers for (east or west).
		// Returns (Array of String): Start marker names in an array.
		public method Array GetMarkersBySide("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return _self.SideMarkersActing;
			};
			
			return _self.SideMarkersOpposing;
		};
		
		// Gets the mission result for a side.
		// This method is used by the framework to get the result and score for a side after a mission is played.
		// _side (Side): The side.
		public method MissionResultInfo GetMissionResult("_side" as Side)
		{
			private ["_missionSide" as MissionSide, "_secondaryObjectiveName" as String];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then
			{
				_secondaryObjectiveName = "";
				
				if (!isNull _self.SecondaryObjectiveForActing) then {
					_secondaryObjectiveName = _self.SecondaryObjectiveForActing.ShortDescription;
				};
				
				return [_self.PrimaryObjectiveForActing.ShortDescription, _self.PrimaryObjectiveCompletedForActing, _secondaryObjectiveName, _self.SecondaryObjectiveCompletedForActing, count _self.ActingPlayers, { [_x] call Mission.IsAlive } count _self.ActingPlayers] new MissionResultInfo;
			}
			else
			{
				_secondaryObjectiveName = "";
				
				if (!isNull _self.SecondaryObjectiveForOpposing) then {
					_secondaryObjectiveName = _self.SecondaryObjectiveForOpposing.ShortDescription;
				};
				
				return [_self.PrimaryObjectiveForOpposing.ShortDescription, _self.PrimaryObjectiveCompletedForOpposing, _secondaryObjectiveName, _self.SecondaryObjectiveCompletedForOpposing, count _self.OpposingPlayers, { [_x] call Mission.IsAlive } count _self.OpposingPlayers] new MissionResultInfo;
			};
		};
		
		public method String GetBriefingInfo("_side" as Side)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				return call _self.AddBriefingInfoForActing;
			};
			
			if (_missionSide == MissionSide.Opposing) then {
				return call _self.AddBriefingInfoForOpposing;
			};
			
			return "";
		};
		
		public method MissionObjective GetMissionObjective("_side" as Side, "_prio" as ObjectivePrio)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting && _prio == ObjectivePrio.Primary) then {
				return _self.PrimaryObjectiveForActing;
			};
			if (_missionSide == MissionSide.Acting && _prio == ObjectivePrio.Secondary) then {
				return _self.SecondaryObjectiveForActing;
			};
			if (_missionSide == MissionSide.Opposing && _prio == ObjectivePrio.Primary) then {
				return _self.PrimaryObjectiveForOpposing;
			};
			if (_missionSide == MissionSide.Opposing && _prio == ObjectivePrio.Secondary) then {
				return _self.SecondaryObjectiveForOpposing;
			};
			
			return classNull;
		};
		
		public method Boolean CheckObjectiveCompleted("_side" as Side, "_prio" as ObjectivePrio)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [_side] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting && _prio == ObjectivePrio.Primary) then {
				if (_self.PrimaryObjectiveCompletedForActing || { call _self.PrimaryObjectiveFulfilledForActing }) then {
					_self.PrimaryObjectiveCompletedForActing = true;
					return true;
				};
				
				return false;
			};
			if (_missionSide == MissionSide.Acting && _prio == ObjectivePrio.Secondary) then {
				if (_self.SecondaryObjectiveCompletedForActing || { call _self.SecondaryObjectiveFulfilledForActing }) then {
					_self.SecondaryObjectiveCompletedForActing = true;
					return true;
				};
				
				return false;
			};
			if (_missionSide == MissionSide.Opposing && _prio == ObjectivePrio.Primary) then {
				if (_self.PrimaryObjectiveCompletedForOpposing || { call _self.PrimaryObjectiveFulfilledForOpposing }) then {
					_self.PrimaryObjectiveCompletedForOpposing = true;
					return true;
				};
				
				return false;
			};
			if (_missionSide == MissionSide.Opposing && _prio == ObjectivePrio.Secondary) then {
				if (_self.SecondaryObjectiveCompletedForOpposing || { call _self.SecondaryObjectiveFulfilledForOpposing }) then {
					_self.SecondaryObjectiveCompletedForOpposing = true;
					return true;
				};
				
				return false;
			};
			
			return false;
		};
		
		// Called one time for each side that performs an insertion to begin carrying out the mission.
		// Called by the campaign, and should never be called by the sub mission class.
		// _group (Group): The group that is being inserted.
		// _position (Array): The position where the group is inserted.
		public method InsertGroup("_group" as Group, "_position" as Array)
		{
			private ["_missionSide" as MissionSide];
			
			_missionSide = [side _group] call _self.GetMissionSide;
			
			if (_missionSide == MissionSide.Acting) then {
				_self.ActingPlayers = units _group;
				[side _group, _position] call _self.OnActingGroupInserted;
			}
			else {
				_self.OpposingPlayers = units _group;
				[side _group, _position] call _self.OnOpposingGroupInserted;
			};
		};
	
		#endregion
		
		#region Virtual (Overridable) Methods
		
		// Initializes mission attributes.
		// This is a lightweight initialization called from the constructor, with a purpose to set
		// attributes like markers and start markers as well ass mission time of day and length. 
		// You should not do anything that alters the world - like creating vehicles or units. As
		// a good practice, in the method of the sub class, begin with a call to _base.Initialize.
		protected override method Initialize()
		{
			_self.Name = "New Mission";
			_self.StartMarkersActing = [];
			_self.StartMarkersOpposing = [];
			_self.StartTimeOfDay = 12;
			_self.RemainingTime = 30;
			_self.SideMarkersActing = [];
			_self.SideMarkersOpposing = [];
		};
		
		// Loads the mission with all gained and lost history items.
		public method SetHistoryTokens("_earlierGainedTokensActing" as Array, "_earlierLostTokensActing" as Array, "_earlierGainedTokensOpposing" as Array, "_earlierLostTokensOpposing" as Array)
		{
			_self.EarlierGainedTokensActing = _earlierGainedTokensActing;
			_self.EarlierLostTokensActing = _earlierLostTokensActing;
			_self.EarlierGainedTokensOpposing = _earlierGainedTokensOpposing;
			_self.EarlierLostTokensOpposing = _earlierLostTokensOpposing;
		};
		
		// Setups the mission, i.e. creating and placing weapons and vehicles, and prepares the mission
		// for the game. Called by the campaign as the first method to be called after the constructor.
		// The default behavior is to skip to correct daytime and create the mission objectives, so 
		// remember to call _base.Setup from the last line in the method of the sub class. This is where
		// you create units like vehicles and AI soldiers.
		public virtual method Setup()
		{
			private _timeToSkip = 24 - daytime + _self.StartTimeOfDay;
			skipTime _timeToSkip;
			
			call _self.CreateMissionObjectives;
		};
		
		// Adds briefing information that is shown to players of the acting side.
		// Override this if you want to show the players some briefing information.
		// Default behavior is to return an empty string.
		// Returns (String): Briefing information. Empty string if no briefing information should be shown.
		protected virtual method String AddBriefingInfoForActing()
		{
			return "";
		};

		// Adds briefing information that is shown to players of the opposing side.
		// Override this if you want to show the players some briefing information.
		// Default behavior is to return an empty string.
		// Returns (String): Briefing information. Empty string if no briefing information should be shown.
		protected virtual method String AddBriefingInfoForOpposing()
		{
			return "";
		};

		// Creates the briefing information regarding the primary objective for the acting side.
		// Called once from method Startup. Override this to create a primary objective for the acting side.
		// Default behavior is to create a mission task that says "Do whatever you want."
		// Returns (MissionTask): Briefing information. Must not return classNull.
		protected virtual method MissionObjective CreatePrimaryObjectiveForActing()
		{
			return ["Survive."] new MissionObjective;
		};
		
		// Creates the briefing information regarding an eventual secondary objective for the acting side.
		// Called once from method Startup. Override this if you want to create a secondary objective for the acting side.
		// Default behavior is to return null - the side has no secondary objective.
		// Returns (MissionTask): Briefing information. classNull if there is no secondary objective.
		protected virtual method MissionObjective CreateSecondaryObjectiveForActing()
		{
			return classNull;
		};
		
		// Creates the briefing information regarding the primary objective for the opposing side.
		// Called once from method Startup. Override this to create a primary objective for the opposing side.
		// Default behavior is to create a mission task that says "Do whatever you want."
		// Returns (MissionTask): Briefing information. Must not return classNull.
		protected virtual method MissionObjective CreatePrimaryObjectiveForOpposing()
		{
			return ["Survive."] new MissionObjective;
		};
		
		// Creates the briefing information regarding an eventual secondary objective for the opposing side.
		// Called once from method Startup. Override this if you want to create a secondary objective for the opposing side.
		// Default behavior is to return null - the side has no secondary objective.
		// Returns (MissionTask): Briefing information. classNull if there is no secondary objective.
		protected virtual method MissionObjective CreateSecondaryObjectiveForOpposing()
		{
			return classNull;
		};
		
		// Performs mission setup for the acting side that may be necessary upon insertion.
		// _side (Side): The side that is inserted.
		// _position (Array): The position where the group is being inserted.
		protected virtual method OnActingGroupInserted("_side" as Side, "_position" as Array)
		{
		};
		
		// Performs mission setup for the opposing side that may be necessary upon insertion.
		// _side (Side): The side that is inserted.
		// _position (Array): The position where the group is being inserted.
		protected virtual method OnOpposingGroupInserted("_side" as Side, "_position" as Array)
		{
		};
		
		// Checks if the primary objective success condition for the acting side is fulfilled.
		// Called continously during the mission until it returns true. Then not again.
		// Override this to specify the condition for when the acting side's primary objective is completed.
		// Default behavior is to return true when mission time has past and players are still alive.
		// Returns (Boolean): true when primary objective for the acting side should count as success, otherwise false.
		protected virtual method Boolean PrimaryObjectiveFulfilledForActing()
		{
			return _self.RemainingTime == 0 && (call _self.CountActingPlayersAlive) > 0;
		};
		
		// Checks if the secondary objective success condition for the acting side is fulfilled.
		// Called continously during the mission until it returns true. Then not again.
		// Override this if the acting side has a secondary objective to specify the condition for when it is completed.
		// Default behavior is to return false - i.e. secondary objective never completes.
		// Returns (Boolean): true when secondary objective for the acting side should count as success, otherwise false.
		protected virtual method Boolean SecondaryObjectiveFulfilledForActing()
		{
			return false;
		};
		
		// Checks if the primary objective success condition for the opposing side is fulfilled.
		// Called continously during the mission until it returns true. Then not again.
		// Override this to specify the condition for when the opposing side's primary objective is completed.
		// Default behavior is to return true when mission time has past and players are still alive.
		// Returns (Boolean): true when primary objective for the opposing side should count as success, otherwise false.
		protected virtual method Boolean PrimaryObjectiveFulfilledForOpposing()
		{
			return _self.RemainingTime == 0 && (call _self.CountOpposingPlayersAlive) > 0;
		};
		
		// Checks if the secondary objective success condition for the opposing side is fulfilled.
		// Called continously during the mission until it returns true. Then not again.
		// Override this if the opposing side has a secondary objective to specify the condition for when it is completed.
		// Default behavior is to return false - i.e. secondary objective never completes.
		// Returns (Boolean): true when secondary objective for the opposing side should count as success, otherwise false.
		protected virtual method Boolean SecondaryObjectiveFulfilledForOpposing()
		{
			return false;
		};
		
		// Checks if mission is fully completed for the acting side, and that there is nothing left for the players to do.
		// Default behavior is to return true if both primary and secondary objectives are completed. If primary objective is 
		// null, then the mission is never considered complete. If secondary 
		// objective is null, then the mission is considered complete when the primary objective is complete.
		// Returns (Boolean): true when mission is fully completed, otherwise false.
		protected virtual method Boolean IsMissionCompleteForActing()
		{
			private ["_primaryObjective" as MissionObjective, "_secondaryObjective" as MissionObjective];
			
			_primaryObjective = _self.PrimaryObjectiveForActing;
			_secondaryObjective = _self.SecondaryObjectiveForActing;
			
			if (isNull _primaryObjective) then {
				return false;
			};
			
			if (_self.PrimaryObjectiveCompletedForActing) then
			{
				if (isNull _secondaryObjective) then {
					return true;
				}
				else {
					return _self.SecondaryObjectiveCompletedForActing;
				};
			};
		};
		
		// Checks if mission is fully completed for the opposing side, and that there is nothing left for the players to do.
		// Default behavior is to return true if both primary and secondary objectives are completed. If primary objective is 
		// null, then the mission is never considered complete. If secondary 
		// objective is null, then the mission is considered complete when the primary objective is complete.
		// Returns (Boolean): true when mission is fully completed, otherwise false.
		protected virtual method Boolean IsMissionCompleteForOpposing()
		{
			private ["_primaryObjective" as MissionObjective, "_secondaryObjective" as MissionObjective];
			
			_primaryObjective = _self.PrimaryObjectiveForOpposing;
			_secondaryObjective = _self.SecondaryObjectiveForOpposing;
			
			if (isNull _primaryObjective) then {
				return false;
			};
			
			if (_self.PrimaryObjectiveCompletedForOpposing) then
			{
				if (isNull _secondaryObjective) then {
					return true;
				}
				else {
					return _self.SecondaryObjectiveCompletedForOpposing;
				};
			};
		};
		
		// Called by the Run method once every iteration (like once a second) during the mission.
		// Override this if you want to monitor something over time - a simpler alternative than overriding
		// the Run method. If you want to end the mission in this method, call _self.Cancel.
		protected virtual method OnEachIteration()
		{
		};
		
		// Runs the mission service.
		// Default behavior is to run the mission until all mission objectives on both sides are completed.
		// Override this if you want other conditions or a more active mission service. Make sure to always
		// exit the service loop if the IsCancelling property reads true, and stop the execution by calling 
		// _self.Cancel, and to to call _base.Run at the end.
		protected override method Run()
		{
			while { !_self.IsCancelling } do
			{
				if (call _self.IsMissionCompleteForActing && call _self.IsMissionCompleteForOpposing) then {
					call _self.Cancel;
				};
				
				call _self.OnEachIteration;
				sleep 1;
			};
			
			call _base.Run;
		};
		
		// Cleans up everything that was created in the Setup method.
		// Default behavior is to delete all vehicles that are created using the spawn methods of this
		// mission base class.
		// Override this if you need to clean up stuff that has been created elsewhere. Remember to call
		// _base.Cleanup.
		public virtual method Cleanup()
		{
			{
				deleteVehicle _x;
			} foreach _mSpawnedSoldiers as Object;
			
			{
				deleteVehicle _x;
			} foreach _mSpawnedVehicles as Object;
		};

		#endregion
	};
};
