/*
 * Name:	CaptureTheAirbase
 * Date:	2020-08-13
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * A mission in which the acting and opposing side will try to capture the airbase.
 * Sides: ACTING is moving in with helicopters, OPPOSING is moving in with armor.
 */

using Tvtcf.Common;
using Tvtcf.Server;
using Campaigns;

namespace Campaigns.ShoeLace
{
	public class CaptureTheAirbase : ShoeLaceMission
	{
		private fields ["_mChopper1" as Object, "_mChopper1State" as TransportState, "_mHelipad1" as Object, "_mChopper1LiftOffTime" as Scalar];
		private fields ["_mChopper2" as Object, "_mChopper2State" as TransportState, "_mHelipad2" as Object, "_mChopper2LiftOffTime" as Scalar];
		private fields ["_mChopper3" as Object, "_mChopper3State" as TransportState, "_mHelipad3" as Object];
		private fields ["_mArmoredTransport1" as Object, "_mArmoredTransportState" as TransportState];
		private fields ["_mTruckTransport1" as Object, "_mTruckTransportState" as TransportState];
		private fields ["_mActingGroup1" as Group, "_mActingGroup2" as Group, "_mActingGroup3" as Group, "_mActingGroup4" as Group];
		private fields ["_mOpposingGroup1" as Group, "_mOpposingGroup2" as Group, "_mOpposingGroup3" as Group];
		private fields ["_mSpawnedIndepententSoldiers" as Array, "_mSpawnedActingSoldiers" as Array, "_mSpawnedOpposingSoldiers" as Array];
		private fields ["_mLeaningToSide" as String, "_mWeaponCacheMarkerActing" as String, "_mWeaponCacheMarkerOpposing" as String];
		private fields ["_mBasicWeaponsActingActionId" as Scalar, "_mExplosivesActingActionId" as Scalar, "_mOpticsActingActionId" as Scalar, "_mSuppliesActingActionId" as Scalar];
		private fields ["_mBasicWeaponsOpposingActionId" as Scalar, "_mExplosivesOpposingActionId" as Scalar, "_mOpticsOpposingActionId" as Scalar, "_mSuppliesOpposingActionId" as Scalar];
		private fields ["_mAmmoBoxActing" as Object, "_mAmmoBoxOpposing" as Object];
		
		// Creates a CaptureTheAirbase object.
		public constructor()
		{
			call _base.Constructor;
			_mChopper1LiftOffTime = 0;
			_mSpawnedIndepententSoldiers = [];
			_mSpawnedActingSoldiers = [];
			_mSpawnedOpposingSoldiers = [];
			_mLeaningToSide = "";
			_mAmmoBoxActing = objNull;
			_mBasicWeaponsActingActionId = -1;
			_mExplosivesActingActionId = -1;
			_mOpticsActingActionId = -1;
			_mSuppliesActingActionId = -1;
			_mBasicWeaponsOpposingActionId = -1;
			_mExplosivesOpposingActionId = -1;
			_mOpticsOpposingActionId = -1;
			_mSuppliesOpposingActionId = -1;
		};
		
		protected override method InitMission("_mission" as MissionSettings)
		{
			_mission.Name = "Capture The Airbase";
			_mission.StartTimeOfDay = 5;
			_mission.StartMarkersActing = ["m11a_StartMarker"];
			_mission.StartMarkersOpposing = ["m11o_StartMarker"];
			_mission.SideMarkersActing = ["m11_AirbaseTowerVincinity", "m11a_WeaponCache", "m11a_InsertionPos"];
			_mission.SideMarkersOpposing = ["m11_AirbaseTowerVincinity", "m11o_WeaponCache", "m11o_InsertionPos"];
			
			_mWeaponCacheMarkerActing = selectRandom ["m11a_AmmoCache1", "m11a_AmmoCache2", "m11a_AmmoCache3", "m11a_AmmoCache4", "m11a_AmmoCache5", "m11a_AmmoCache6", "m11a_AmmoCache7", "m11a_AmmoCache8", "m11a_AmmoCache9", "m11a_AmmoCache10", "m11a_AmmoCache11"];
			_mWeaponCacheMarkerOpposing = selectRandom ["m11o_AmmoCache1", "m11o_AmmoCache2", "m11o_AmmoCache3", "m11o_AmmoCache4", "m11o_AmmoCache5", "m11o_AmmoCache6", "m11o_AmmoCache7", "m11o_AmmoCache8", "m11o_AmmoCache9", "m11o_AmmoCache10"];
			
			"m11a_WeaponCache" setMarkerPos markerPos _mWeaponCacheMarkerActing;
			"m11o_WeaponCache" setMarkerPos markerPos _mWeaponCacheMarkerOpposing;
		};
		
		protected override method Setup()
		{
			// Acting
			
			// Weapon Cache
			
			var _box = "I_supplyCrate_F" createVehicle getMarkerPos _mWeaponCacheMarkerActing;
			[_box] call _self.MakeEmptyAmmoBox;
			[_box, MissionSide.Acting] call _self.FillBoxWithOptics;
			[_box, MissionSide.Acting] call _self.FillBoxWithSupplies;
			[_box, MissionSide.Acting] call _self.FillBoxWithExplosives;

			if (!("BASIC WEAPONS" in _self.GainedTokensActing)) then {
				_mBasicWeaponsActingActionId = [_box, "Take Basic Weapons (and leave the rest)", MissionSide.Acting] call _self.AddAction;
			};
			
			if (!("EXPLOSIVES" in _self.GainedTokensActing)) then {
				_mExplosivesActingActionId = [_box, "Take Explosives (and leave the rest)", MissionSide.Acting] call _self.AddAction;
			};
			
			_mOpticsActingActionId = [_box, "Take Optics (and leave the rest)", MissionSide.Acting] call _self.AddAction;
			_mSuppliesActingActionId = [_box, "Take Supplies (and leave the rest)", MissionSide.Acting] call _self.AddAction;

			_mAmmoBoxActing = _box;

			// Helicopters
			
			_mChopper1 = ["TRANSPORT HELICOPTER", "m11a_Helicopter1", MissionSide.Acting, false, true] call _self.CreateSideVehicleOnMarker;
			_mChopper1 engineOn true;
			_mChopper1 lock true;
			_mChopper1State = TransportState.Waiting;
			{ _x setCaptive true; } foreach crew _mChopper1;
			
			_mChopper2 = ["TRANSPORT HELICOPTER", "m11a_Helicopter2", MissionSide.Acting, false, true] call _self.CreateSideVehicleOnMarker;
			_mChopper2 engineOn true;
			_mChopper2 lock true;
			_mChopper2State = TransportState.Waiting;
			{ _x setCaptive true; } foreach crew _mChopper2;
			
			_mChopper3 = ["TRANSPORT HELICOPTER", "m11a_Helicopter3", MissionSide.Acting, false, true] call _self.CreateSideVehicleOnMarker;
			_mChopper3 engineOn true;
			_mChopper3State = TransportState.Waiting;
			{ _mChopper3 lockTurret [_x, true]; } foreach (allTurrets _mChopper3) as Array;
			_mChopper3 lockDriver true;
			{ _x setCaptive true; } foreach crew _mChopper3;
			
			// Soldiers
			
			private _rifleman1 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting] call _self.CreateSideAiSoldier;
			_mActingGroup1 = group _rifleman1;
			private _rifleman2 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup1] call _self.CreateSideAiSoldier;
			private _rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup1] call _self.CreateSideAiSoldier;
			_mSpawnedActingSoldiers = _mSpawnedActingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x moveInCargo _mChopper1;
				_x assignAsCargo _mChopper1;
			} foreach units _mActingGroup1 as Object;
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting] call _self.CreateSideAiSoldier;
			_mActingGroup2 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup2] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup2] call _self.CreateSideAiSoldier;
			_mSpawnedActingSoldiers = _mSpawnedActingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x moveInCargo _mChopper1;
				_x assignAsCargo _mChopper1;
			} foreach units _mActingGroup2 as Object;
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting] call _self.CreateSideAiSoldier;
			_mActingGroup3 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup3] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup3] call _self.CreateSideAiSoldier;
			_mSpawnedActingSoldiers = _mSpawnedActingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x moveInCargo _mChopper2;
				_x assignAsCargo _mChopper2;
			} foreach units _mActingGroup3 as Object;
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting] call _self.CreateSideAiSoldier;
			_mActingGroup4 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup4] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11a_SoldierSpawnPoint", MissionSide.Acting, _mActingGroup4] call _self.CreateSideAiSoldier;
			_mSpawnedActingSoldiers = _mSpawnedActingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x moveInCargo _mChopper2;
				_x assignAsCargo _mChopper2;
			} foreach units _mActingGroup4 as Object;
			
			_mHelipad1 = "Land_HelipadEmpty_F" createVehicle getMarkerPos "m11a_LandingZone1";
			_mHelipad2 = "Land_HelipadEmpty_F" createVehicle getMarkerPos "m11a_LandingZone2";
			_mHelipad3 = "Land_HelipadEmpty_F" createVehicle getMarkerPos "m11a_LandingZone3";
			
			// Other
			
			["AMMOBOX LAUNCHERS", BaseMarker.AmmoCrate, MissionSide.Acting, true] call _self.CreateSideVehicleInBase;
			
			// Opposing
			
			// Weapon Cache
			
			_box = "I_supplyCrate_F" createVehicle getMarkerPos _mWeaponCacheMarkerOpposing;
			[_box] call _self.MakeEmptyAmmoBox;
			[_box, MissionSide.Opposing] call _self.FillBoxWithOptics;
			[_box, MissionSide.Opposing] call _self.FillBoxWithSupplies;
			[_box, MissionSide.Opposing] call _self.FillBoxWithExplosives;

			if (!("BASIC WEAPONS" in _self.GainedTokensOpposing)) then {
				_mBasicWeaponsOpposingActionId = [_box, "Take Basic Weapons (and leave the rest)", MissionSide.Opposing] call _self.AddAction;
			};
			
			if (!("EXPLOSIVES" in _self.GainedTokensOpposing)) then {
				_mExplosivesOpposingActionId = [_box, "Take Explosives (and leave the rest)", MissionSide.Opposing] call _self.AddAction;
			};
			
			_mOpticsOpposingActionId = [_box, "Take Optics (and leave the rest)", MissionSide.Opposing] call _self.AddAction;
			_mSuppliesOpposingActionId = [_box, "Take Supplies (and leave the rest)", MissionSide.Opposing] call _self.AddAction;

			_mAmmoBoxOpposing = _box;
			
			// Armored Transport
			
			_mArmoredTransport1 = ["APC TRANSPORT CANNON", "m11o_ArmoredTransport1", MissionSide.Opposing, false, true] call _self.CreateSideVehicleOnMarker;
			{ _mArmoredTransport1 lockTurret [_x, true]; } foreach (allTurrets _mArmoredTransport1) as Array;
			_mArmoredTransport1 lockDriver true;
			_mArmoredTransportState = TransportState.Waiting;
			_mSpawnedOpposingSoldiers = _mSpawnedOpposingSoldiers + units group _mArmoredTransport1;
			{ _x setCaptive true; } foreach crew _mArmoredTransport1;
			
			_mTruckTransport1 = ["TRANSPORT TRUCK", "m11o_TransportTruck", MissionSide.Opposing, false, true] call _self.CreateSideVehicleOnMarker;
			_mTruckTransportState = TransportState.Waiting;
			_mSpawnedOpposingSoldiers = _mSpawnedOpposingSoldiers + units group _mTruckTransport1;
			{ _x setCaptive true; } foreach crew _mTruckTransport1;
			
			// Soldiers
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing] call _self.CreateSideAiSoldier;
			_mOpposingGroup1 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup1] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup1] call _self.CreateSideAiSoldier;
			_mSpawnedOpposingSoldiers = _mSpawnedOpposingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x assignAsCargo _mTruckTransport1;
			} foreach units _mOpposingGroup1 as Object;
			(units _mOpposingGroup1) orderGetIn true;
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing] call _self.CreateSideAiSoldier;
			_mOpposingGroup2 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup2] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup2] call _self.CreateSideAiSoldier;
			_mSpawnedOpposingSoldiers = _mSpawnedOpposingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x assignAsCargo _mTruckTransport1;
			} foreach units _mOpposingGroup2 as Object;
			(units _mOpposingGroup2) orderGetIn true;
			
			_rifleman1 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing] call _self.CreateSideAiSoldier;
			_mOpposingGroup3 = group _rifleman1;
			_rifleman2 = ["RIFLEMAN", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup3] call _self.CreateSideAiSoldier;
			_rifleman3 = ["RIFLEMAN AT", getMarkerPos "m11o_SoldierSpawnPoint", MissionSide.Opposing, _mOpposingGroup3] call _self.CreateSideAiSoldier;
			_mSpawnedOpposingSoldiers = _mSpawnedOpposingSoldiers + [_rifleman1, _rifleman2, _rifleman3];
			
			{
				_x assignAsCargo _mTruckTransport1;
			} foreach units _mOpposingGroup3 as Object;
			(units _mOpposingGroup3) orderGetIn true;
			
			// Independent
			
			var _pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			var _group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_Soldier_LAT_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
		
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
			
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_Soldier_LAT_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
		
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
			
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_Soldier_LAT_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
		
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
			
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_Soldier_LAT_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
		
			_pos = ["m_Airbase"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker;
			_group = createGroup [independent, true];
			_rifleman1 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			_rifleman2 = ["I_soldier_F", _pos, _group] call _self.CreateAiSoldier;
			[group _rifleman1, "m_Airbase"] execVM "Engima\SearchPatrol\SearchPatrol.sqf";
			_mSpawnedIndepententSoldiers = _mSpawnedIndepententSoldiers + [_rifleman1, _rifleman2];
			
			call _base.Setup;
		};
		
		public override method OnAction("_actionId" as Scalar, "_target" as Object, "_actor" as Object)
		{
			if (_target == _mAmmoBoxActing) then
			{
				var _token = "";
			
				switch (_actionId) do {
					case _mBasicWeaponsActingActionId: { _token = "BASIC WEAPONS" };
					case _mExplosivesActingActionId: { _token = "EXPLOSIVES" };
					case _mOpticsActingActionId: { _token = "OPTICS" };
					case _mSuppliesActingActionId: { _token = "SUPPLIES" };
				};
				
				if (_token != "") then {
					_self.GainedTokensActing pushBack _token;
					[MissionSide.Acting, "Gained: " + _token] call _self.ShowNotification;
					
					[[
						_mBasicWeaponsActingActionId,
						_mExplosivesActingActionId,
						_mOpticsActingActionId,
						_mSuppliesActingActionId]
					] call _self.DeleteActions;
				};
			};
			
			if (_target == _mAmmoBoxOpposing) then
			{
				var _token = "";
			
				switch (_actionId) do {
					case _mBasicWeaponsOpposingActionId: { _token = "BASIC WEAPONS" };
					case _mExplosivesOpposingActionId: { _token = "EXPLOSIVES" };
					case _mOpticsOpposingActionId: { _token = "OPTICS" };
					case _mSuppliesOpposingActionId: { _token = "SUPPLIES" };
				};
				
				if (_token != "") then {
					_self.GainedTokensOpposing pushBack _token;
					[MissionSide.Opposing, "Gained: " + _token] call _self.ShowNotification;
					
					[[
						_mBasicWeaponsOpposingActionId,
						_mExplosivesOpposingActionId,
						_mOpticsOpposingActionId,
						_mSuppliesOpposingActionId]
					] call _self.DeleteActions;
				};
			};
		};
		
		protected override method String AddBriefingInfoForActing()
		{
			var _p1 = "The Stratis Airbase is one of the keys in our operation. We need to capture it to enable an easier resupply chain from our main forces, and so that we do not risk it falling into enemy hands.";
			var _p2 = "<br /><br />We know about an ammo cache. If you find an opportunity you may try to go there and secure something of interest for the rest of our operation [use the action menu].";
			var _p3 = "<br /><br />Remember to bring AT launchers!";
		
			return _p1 + _p2 + _p3 + call _base.AddBriefingInfoForActing;
		};
		
		protected override method String AddBriefingInfoForOpposing()
		{
			var _p1 = "The Stratis Airbase is one of the keys in our operation. We need to capture it to enable an easier resupply chain from our main forces, and so that we do not risk it falling into enemy hands.";
			var _p2 = "<br /><br />We know about an ammo cache. If you find an opportunity you may try to go there and secure something of interest for the rest of our operation [use the action menu].";
			
			return _p1 + _p2 + call _base.AddBriefingInfoForOpposing;
		};
		
		protected override method MissionObjective CreatePrimaryObjectiveForActing()
		{
			return ["Capture the airbase.", "Assist the brigade in siezing the tower and clear the tower's closest surroundings (250 meters) of enemy forces. Join them at Camp Maxwell and board the helicopter as quickly as you can!"] new MissionObjective;
		};
		
		protected override method MissionObjective CreatePrimaryObjectiveForOpposing()
		{
			return ["Capture the airbase.", "Assist the brigade in siezing the tower and clear the tower's closest surroundings (250 meters) of enemy forces. Join them at Agia Marina and board the armored transport as quickly as you can!"] new MissionObjective;
		};
		
		private method Scalar CountUnitsNearTower("_units" as Array)
		{
			private _count = 0;
			
			{
				if (alive _x && _x distance getMarkerPos "m11_AirbaseTowerVincinity" < 250) then {
					_count = _count + 1;
				};
			} foreach _units as Object;
			
			return _count;
		};
		
		protected override method ObjectiveState CheckPrimaryObjectiveStateActing()
		{
			// If the other side has won, we will lose.
			
			if (_self.PrimaryObjectiveStateOpposing == ObjectiveState.Succeeded) then {
				return ObjectiveState.Failed;
			};
			
			// If all players are dead, or if time is up, then victory goes to the one with most allied in the tower area.
			
			var _friendliesCloseToTowerCount = ([_mSpawnedActingSoldiers] call _self.CountUnitsNearTower) + ([_self.ActingUnits] call _self.CountUnitsNearTower);
			var _enemiesCloseToTowerCount = ([_mSpawnedOpposingSoldiers] call _self.CountUnitsNearTower) + ([_mSpawnedIndepententSoldiers] call _self.CountUnitsNearTower) + ([_self.OpposingUnits] call _self.CountUnitsNearTower);
			var _allPlayersAreDead = ([MissionSide.Acting] call _self.CountPlayersAliveOnSide) + ([MissionSide.Opposing] call _self.CountPlayersAliveOnSide) == 0;
			
			if (_self.RemainingTime == 0 || _allPlayersAreDead) then
			{
				if (_friendliesCloseToTowerCount >= _enemiesCloseToTowerCount) then {
					_self.GainedTokensActing pushBack "AIRBASE";
					return ObjectiveState.Succeeded;
				};
			};
			
			// At any time, if friendlies are more than five times more than enemies, domination is a fact.
			
			if (_friendliesCloseToTowerCount > _enemiesCloseToTowerCount * 5) then {
				_self.GainedTokensActing pushBack "AIRBASE";
				return ObjectiveState.Succeeded;
			};
			
			// If there are very few enemies left, and we are more then thay are, we have won.
			
			private _totalUnitsCount = ({alive _x} count _mSpawnedActingSoldiers) + ({alive _x} count _mSpawnedOpposingSoldiers) + ({alive _x} count _mSpawnedIndepententSoldiers) + (call _self.CountUnitsAliveActing) + (call _self.CountUnitsAliveOpposing);
			
			if (_totalUnitsCount < 10 && _enemiesCloseToTowerCount <= 2 && _friendliesCloseToTowerCount > _enemiesCloseToTowerCount) then {
				_self.GainedTokensActing pushBack "AIRBASE";
				return ObjectiveState.Succeeded;
			};
		
			return ObjectiveState.None;
		};
		
		protected override method ObjectiveState CheckPrimaryObjectiveStateOpposing()
		{
			// If the other side has won, we will lose
			
			if (_self.PrimaryObjectiveStateActing == ObjectiveState.Succeeded) then {
				return ObjectiveState.Failed;
			};
			
			// If all players are dead, then victory goes to the one with most allied in the tower area.
			
			var _friendliesCloseToTowerCount = ([_mSpawnedOpposingSoldiers] call _self.CountUnitsNearTower) + ([_self.OpposingUnits] call _self.CountUnitsNearTower);
			var _enemiesCloseToTowerCount = ([_mSpawnedActingSoldiers] call _self.CountUnitsNearTower) + ([_mSpawnedIndepententSoldiers] call _self.CountUnitsNearTower) + ([_self.ActingUnits] call _self.CountUnitsNearTower);
			var _allPlayersAreDead = ([MissionSide.Opposing] call _self.CountPlayersAliveOnSide) + ([MissionSide.Acting] call _self.CountPlayersAliveOnSide) == 0;
			
			if (_self.RemainingTime == 0 || _allPlayersAreDead) then
			{
				if (_friendliesCloseToTowerCount >= _enemiesCloseToTowerCount) then {
					_self.GainedTokensOpposing pushBack "AIRBASE";
					return ObjectiveState.Succeeded;
				};
			};
			
			// At any time, if friendlies are more than five times more than enemies, domination is a fact.
			
			if (_friendliesCloseToTowerCount > _enemiesCloseToTowerCount * 5) then {
				_self.GainedTokensOpposing pushBack "AIRBASE";
				return ObjectiveState.Succeeded;
			};
			
			// If there are very few enemies left, and we are more then thay are, we have won.
			
			private _totalUnitsCount = ({alive _x} count _mSpawnedActingSoldiers) + ({alive _x} count _mSpawnedOpposingSoldiers) + ({alive _x} count _mSpawnedIndepententSoldiers) + (call _self.CountUnitsAliveActing) + (call _self.CountUnitsAliveOpposing);
			
			if (_totalUnitsCount < 10 && _enemiesCloseToTowerCount <= 2 && _friendliesCloseToTowerCount > _enemiesCloseToTowerCount) then {
				_self.GainedTokensOpposing pushBack "AIRBASE";
				return ObjectiveState.Succeeded;
			};
		
			return ObjectiveState.None;
		};
		
		protected override method OnActingGroupInserted("_e" as InsertionEventArgs)
		{
			[MissionSide.Acting, "Enter the helicopter"] call _self.ShowNotification;
			[_e] call _base.OnActingGroupInserted;
		};
		
		protected override method OnOpposingGroupInserted("_e" as InsertionEventArgs)
		{
			[MissionSide.Opposing, "Enter the armored transport"] call _self.ShowNotification;
			[_e] call _base.OnOpposingGroupInserted;
		};
		
		protected override method OnEachIteration()
		{
			private _actingCloseToTowerCount = ([_mSpawnedActingSoldiers] call _self.CountUnitsNearTower) + ([_self.ActingUnits] call _self.CountUnitsNearTower);
			private _opposingCloseToTowerCount = ([_mSpawnedOpposingSoldiers] call _self.CountUnitsNearTower) + ([_self.OpposingUnits] call _self.CountUnitsNearTower);
			private _indepentendCloseToTowerCount = [_mSpawnedIndepententSoldiers] call _self.CountUnitsNearTower;
			
			//private _total = ({alive _x} count _mSpawnedActingSoldiers) + ({alive _x} count _mSpawnedOpposingSoldiers) + ({alive _x} count _mSpawnedIndepententSoldiers) + (call _self.CountUnitsAliveActing) + (call _self.CountUnitsAliveOpposing);
			//hint ("A: " + str _actingCloseToTowerCount + ", O: " + str _opposingCloseToTowerCount + ", I: " + str _indepentendCloseToTowerCount + ", T: " + str _total);
		
			// Check if one of the sides are about to win
			if (_actingCloseToTowerCount >= (_opposingCloseToTowerCount + _indepentendCloseToTowerCount) * 1.5 && _mLeaningToSide != "ACTING") then {
				[MissionSide.Acting, "Winning momentum."] call _self.ShowNotification;
				[MissionSide.Opposing, "Loosing momentum."] call _self.ShowNotification;
				_mLeaningToSide = "ACTING";
			};
			
			if (_opposingCloseToTowerCount >= (_actingCloseToTowerCount + _indepentendCloseToTowerCount) * 1.5 && _mLeaningToSide != "OPPOSING") then {
				[MissionSide.Acting, "Loosing momentum."] call _self.ShowNotification;
				[MissionSide.Opposing, "Winning momentum."] call _self.ShowNotification;
				_mLeaningToSide = "OPPOSING";
			};
		
			// Acting

			// Chopper 1
			
			if (_mChopper1State == TransportState.Waiting) then
			{
				private _allPlayersInChopper = { alive _x && vehicle _x == _mChopper3 } count _self.ActingUnits == call _self.CountUnitsAliveActing;

				if (_allPlayersInChopper) then {
					private _waypoint = (group driver _mChopper1) addWaypoint [getMarkerPos "m11a_FirstChopperWaypoint", 0];
					_waypoint setWaypointBehaviour "CARELESS";
					_waypoint = (group driver _mChopper1) addWaypoint [getMarkerPos "m11a_LandingZone1", 0];
					_mChopper1LiftOffTime = time;
					_mChopper1State = TransportState.Transporting;
				};
			};

			if (_mChopper1State == TransportState.Transporting) then {
				if (_mChopper1 distance2D getMarkerPos "m11a_LandingZone1" < 150 && unitReady _mChopper1) then {
					_mChopper1 land "LAND";
					_mChopper1State = TransportState.Landing;
				};
			};
			
			if (_mChopper1State == TransportState.Landing) then {
				if ((getPosATL _mChopper1) select 2 < 1) then {
					_mActingGroup1 leaveVehicle _mChopper1;
					_mActingGroup2 leaveVehicle _mChopper1;
					[_mActingGroup1] call _self.AddInfantrySadWaypoints;
					[_mActingGroup2] call _self.AddInfantrySadWaypoints;
					
					var _waypoint = (group driver _mChopper1) addWaypoint [getMarkerPos "m11a_Helicopter1", 0];
					_waypoint setWaypointSpeed "FULL";
					_waypoint setWaypointBehaviour "CARELESS";
					_mChopper1State = TransportState.Returning;
				};
			};

			// Chopper 2
			
			if (_mChopper2State == TransportState.Waiting && _mChopper1State == TransportState.Transporting && time > _mChopper1LiftOffTime + 3) then
			{
				private _waypoint = (group driver _mChopper2) addWaypoint [getMarkerPos "m11a_FirstChopperWaypoint", 0];
				_waypoint setWaypointBehaviour "CARELESS";
				_waypoint = (group driver _mChopper2) addWaypoint [getMarkerPos "m11a_LandingZone2", 0];
				_mChopper2LiftOffTime = time;
				_mChopper2State = TransportState.Transporting;
			};

			if (_mChopper2State == TransportState.Transporting) then {
				if (_mChopper2 distance2D getMarkerPos "m11a_LandingZone2" < 150 && unitReady _mChopper2) then {
					_mChopper2 land "LAND";
					_mChopper2State = TransportState.Landing;
				};
			};
			
			if (_mChopper2State == TransportState.Landing) then {
				if ((getPosATL _mChopper1) select 2 < 1) then {
					_mActingGroup3 leaveVehicle _mChopper2;
					_mActingGroup4 leaveVehicle _mChopper2;
					[_mActingGroup3] call _self.AddInfantrySadWaypoints;
					[_mActingGroup4] call _self.AddInfantrySadWaypoints;
					
					var _waypoint = (group driver _mChopper2) addWaypoint [getMarkerPos "m11a_Helicopter2", 0];
					_waypoint setWaypointSpeed "FULL";
					_waypoint setWaypointBehaviour "CARELESS";
					_mChopper2State = TransportState.Returning;
				};
			};

			// Chopper 3 (players' chopper)
			
			if (_mChopper3State == TransportState.Waiting && _mChopper2State == TransportState.Transporting && time > _mChopper2LiftOffTime + 3) then
			{
				private _allPlayersInChopper = { alive _x && vehicle _x == _mChopper3 } count _self.ActingUnits == call _self.CountUnitsAliveActing;

				if (_allPlayersInChopper) then {
					private _waypoint = (group driver _mChopper3) addWaypoint [getMarkerPos "m11a_FirstChopperWaypoint", 0];
					_waypoint setWaypointBehaviour "CARELESS";
					_waypoint = (group driver _mChopper3) addWaypoint [getMarkerPos "m11a_LandingZone3", 0];
					_mChopper3State = TransportState.Transporting;
				};
			};

			if (_mChopper3State == TransportState.Transporting) then {
				if (_mChopper3 distance2D getMarkerPos "m11a_LandingZone3" < 150 && unitReady _mChopper3) then {
					_mChopper3 land "LAND";
					_mChopper3State = TransportState.Landing;
				};
			};
			
			if (_mChopper3State == TransportState.Landing) then {
				private _allUnitsHasExited = { alive _x && vehicle _x == _mChopper3 } count _self.ActingUnits == 0;
			
				if (_allUnitsHasExited) then {
					var _waypoint = (group driver _mChopper3) addWaypoint [getMarkerPos "m11a_Helicopter3", 0];
					_waypoint setWaypointSpeed "FULL";
					_waypoint setWaypointBehaviour "CARELESS";
				};
			};

			// Opposing
			
			if (_mArmoredTransportState == TransportState.Waiting) then {
				private _allPlayersIn = { alive _x && vehicle _x == _mArmoredTransport1 } count _self.OpposingUnits == call _self.CountUnitsAliveOpposing;

				if (_allPlayersIn) then {
					private _waypoint = (group driver _mArmoredTransport1) addWaypoint [getMarkerPos "m11o_ArmorUnloadMarker", 50];
					_waypoint setWaypointBehaviour "AWARE";
					(group driver _mArmoredTransport1) setBehaviour "AWARE";
					_mArmoredTransportState = TransportState.Transporting;
				};
			};
			
			if (_mArmoredTransportState == TransportState.Transporting) then {
				if (_mArmoredTransport1 distance2D getMarkerPos "m11o_ArmorUnloadMarker" < 50) then {
					_mArmoredTransportState = TransportState.Unloading;
					_mArmoredTransport1 limitSpeed 0;
					[MissionSide.Opposing, "Disembark!"] call _self.ShowNotification;
				};
			};
			
			if (_mArmoredTransportState == TransportState.Unloading) then {
				private _allPlayersOut = { alive _x && vehicle _x == _mArmoredTransport1 } count _self.OpposingUnits == 0;

				if (_allPlayersOut) then {
					[group driver _mArmoredTransport1] call _self.AddInfantrySadWaypoints;
					_mArmoredTransport1 limitSpeed 10;
					_mArmoredTransportState = TransportState.Returning;
				};
			};
			
			if (_mTruckTransportState == TransportState.Waiting) then {
				if (_mArmoredTransportState == TransportState.Transporting) then {
					private _waypoint = (group driver _mTruckTransport1) addWaypoint [getMarkerPos "m11o_TruckUnloadMarker", 50];
					_waypoint setWaypointBehaviour "AWARE";
					(group driver _mTruckTransport1) setBehaviour "AWARE";
					_mTruckTransportState = TransportState.Transporting;
				};
			};
			
			if (_mTruckTransportState == TransportState.Transporting) then {
				if (_mTruckTransport1 distance2D getMarkerPos "m11o_TruckUnloadMarker" < 50) then {
					_mTruckTransportState = TransportState.Unloading;
					_mTruckTransport1 limitSpeed 0;
				};
			};
			
			if (_mTruckTransportState == TransportState.Unloading) then {
				_mOpposingGroup1 leaveVehicle _mTruckTransport1;
				_mOpposingGroup2 leaveVehicle _mTruckTransport1;
				_mOpposingGroup3 leaveVehicle _mTruckTransport1;
				[_mOpposingGroup1] call _self.AddInfantrySadWaypoints;
				[_mOpposingGroup2] call _self.AddInfantrySadWaypoints;
				[_mOpposingGroup3] call _self.AddInfantrySadWaypoints;
				_mTruckTransportState = TransportState.Returning;
				{ _x setCaptive false; } foreach crew _mArmoredTransport1;
			};
		};
		
		private method AddInfantrySadWaypoints("_group" as Group)
		{
			for "_i" from 0 to 20 do {
				private _waypoint = _group addWaypoint [["m11_AirbaseTowerVincinity"] call Sqx.Markers.MarkerHelper.GetRandomPosInsideMarker, 25];
				_waypoint setWaypointType selectRandom ["MOVE", "SAD"];
				_waypoint setWaypointBehaviour selectRandom ["AWARE", "COMBAT"];
				_waypoint setWaypointCombatMode selectRandom ["YELLOW", "RED"];
				_waypoint setWaypointSpeed selectRandom ["FULL", "NORMAL"];
			};
		};
		
		public override method Cleanup()
		{
			deleteVehicle _mHelipad1;
			deleteVehicle _mHelipad2;
			deleteVehicle _mHelipad3;
		};
	};
};
